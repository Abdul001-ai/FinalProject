"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-aria+landmark@3.0.4__bc97dcb7c0bda8e89a4b199239a5e139";
exports.ids = ["vendor-chunks/@react-aria+landmark@3.0.4__bc97dcb7c0bda8e89a4b199239a5e139"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-aria+landmark@3.0.4__bc97dcb7c0bda8e89a4b199239a5e139/node_modules/@react-aria/landmark/dist/useLandmark.mjs":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-aria+landmark@3.0.4__bc97dcb7c0bda8e89a4b199239a5e139/node_modules/@react-aria/landmark/dist/useLandmark.mjs ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UNSTABLE_createLandmarkController: () => (/* binding */ $a86207c5d7f7e1fb$export$a8e2debc6521490c),\n/* harmony export */   useLandmark: () => (/* binding */ $a86207c5d7f7e1fb$export$4cc632584fd87fae)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.3.5_@babel+core@7.2_59a685cecc86146db29560d6fd5f016c/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/.pnpm/@react-aria+utils@3.29.1_re_da3b841b3fb7c59497c9aff390c601da/node_modules/@react-aria/utils/dist/useLayoutEffect.mjs\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/index.js\");\n\n\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n// Increment this version number whenever the\n// LandmarkManagerApi or Landmark interfaces change.\nconst $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION = 1;\n// Symbol under which the singleton landmark manager instance is attached to the document.\nconst $a86207c5d7f7e1fb$var$landmarkSymbol = Symbol.for('react-aria-landmark-manager');\nfunction $a86207c5d7f7e1fb$var$subscribe(fn) {\n    document.addEventListener('react-aria-landmark-manager-change', fn);\n    return ()=>document.removeEventListener('react-aria-landmark-manager-change', fn);\n}\nfunction $a86207c5d7f7e1fb$var$getLandmarkManager() {\n    if (typeof document === 'undefined') return null;\n    // Reuse an existing instance if it has the same or greater version.\n    let instance = document[$a86207c5d7f7e1fb$var$landmarkSymbol];\n    if (instance && instance.version >= $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION) return instance;\n    // Otherwise, create a new instance and dispatch an event so anything using the existing\n    // instance updates and re-registers their landmarks with the new one.\n    document[$a86207c5d7f7e1fb$var$landmarkSymbol] = new $a86207c5d7f7e1fb$var$LandmarkManager();\n    document.dispatchEvent(new CustomEvent('react-aria-landmark-manager-change'));\n    return document[$a86207c5d7f7e1fb$var$landmarkSymbol];\n}\n// Subscribes a React component to the current landmark manager instance.\nfunction $a86207c5d7f7e1fb$var$useLandmarkManager() {\n    return (0, use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)($a86207c5d7f7e1fb$var$subscribe, $a86207c5d7f7e1fb$var$getLandmarkManager, $a86207c5d7f7e1fb$var$getLandmarkManager);\n}\nclass $a86207c5d7f7e1fb$var$LandmarkManager {\n    setupIfNeeded() {\n        if (this.isListening) return;\n        document.addEventListener('keydown', this.f6Handler, {\n            capture: true\n        });\n        document.addEventListener('focusin', this.focusinHandler, {\n            capture: true\n        });\n        document.addEventListener('focusout', this.focusoutHandler, {\n            capture: true\n        });\n        this.isListening = true;\n    }\n    teardownIfNeeded() {\n        if (!this.isListening || this.landmarks.length > 0 || this.refCount > 0) return;\n        document.removeEventListener('keydown', this.f6Handler, {\n            capture: true\n        });\n        document.removeEventListener('focusin', this.focusinHandler, {\n            capture: true\n        });\n        document.removeEventListener('focusout', this.focusoutHandler, {\n            capture: true\n        });\n        this.isListening = false;\n    }\n    focusLandmark(landmark, direction) {\n        var _this_landmarks_find_focus, _this_landmarks_find;\n        (_this_landmarks_find = this.landmarks.find((l)=>l.ref.current === landmark)) === null || _this_landmarks_find === void 0 ? void 0 : (_this_landmarks_find_focus = _this_landmarks_find.focus) === null || _this_landmarks_find_focus === void 0 ? void 0 : _this_landmarks_find_focus.call(_this_landmarks_find, direction);\n    }\n    /**\n   * Return set of landmarks with a specific role.\n   */ getLandmarksByRole(role) {\n        return new Set(this.landmarks.filter((l)=>l.role === role));\n    }\n    /**\n   * Return first landmark with a specific role.\n   */ getLandmarkByRole(role) {\n        return this.landmarks.find((l)=>l.role === role);\n    }\n    addLandmark(newLandmark) {\n        this.setupIfNeeded();\n        if (this.landmarks.find((landmark)=>landmark.ref === newLandmark.ref) || !newLandmark.ref.current) return;\n        if (this.landmarks.filter((landmark)=>landmark.role === 'main').length > 1 && \"development\" !== 'production') console.error('Page can contain no more than one landmark with the role \"main\".');\n        if (this.landmarks.length === 0) {\n            this.landmarks = [\n                newLandmark\n            ];\n            this.checkLabels(newLandmark.role);\n            return;\n        }\n        // Binary search to insert new landmark based on position in document relative to existing landmarks.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        let start = 0;\n        let end = this.landmarks.length - 1;\n        while(start <= end){\n            let mid = Math.floor((start + end) / 2);\n            let comparedPosition = newLandmark.ref.current.compareDocumentPosition(this.landmarks[mid].ref.current);\n            let isNewAfterExisting = Boolean(comparedPosition & Node.DOCUMENT_POSITION_PRECEDING || comparedPosition & Node.DOCUMENT_POSITION_CONTAINS);\n            if (isNewAfterExisting) start = mid + 1;\n            else end = mid - 1;\n        }\n        this.landmarks.splice(start, 0, newLandmark);\n        this.checkLabels(newLandmark.role);\n    }\n    updateLandmark(landmark) {\n        let index = this.landmarks.findIndex((l)=>l.ref === landmark.ref);\n        if (index >= 0) {\n            this.landmarks[index] = {\n                ...this.landmarks[index],\n                ...landmark\n            };\n            this.checkLabels(this.landmarks[index].role);\n        }\n    }\n    removeLandmark(ref) {\n        this.landmarks = this.landmarks.filter((landmark)=>landmark.ref !== ref);\n        this.teardownIfNeeded();\n    }\n    /**\n   * Warn if there are 2+ landmarks with the same role but no label.\n   * Labels for landmarks with the same role must also be unique.\n   *\n   * See https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/.\n   */ checkLabels(role) {\n        let landmarksWithRole = this.getLandmarksByRole(role);\n        if (landmarksWithRole.size > 1) {\n            let duplicatesWithoutLabel = [\n                ...landmarksWithRole\n            ].filter((landmark)=>!landmark.label);\n            if (duplicatesWithoutLabel.length > 0 && \"development\" !== 'production') console.warn(`Page contains more than one landmark with the '${role}' role. If two or more landmarks on a page share the same role, all must be labeled with an aria-label or aria-labelledby attribute: `, duplicatesWithoutLabel.map((landmark)=>landmark.ref.current));\n            else if (true) {\n                let labels = [\n                    ...landmarksWithRole\n                ].map((landmark)=>landmark.label);\n                let duplicateLabels = labels.filter((item, index)=>labels.indexOf(item) !== index);\n                duplicateLabels.forEach((label)=>{\n                    console.warn(`Page contains more than one landmark with the '${role}' role and '${label}' label. If two or more landmarks on a page share the same role, they must have unique labels: `, [\n                        ...landmarksWithRole\n                    ].filter((landmark)=>landmark.label === label).map((landmark)=>landmark.ref.current));\n                });\n            }\n        }\n    }\n    /**\n   * Get the landmark that is the closest parent in the DOM.\n   * Returns undefined if no parent is a landmark.\n   */ closestLandmark(element) {\n        let landmarkMap = new Map(this.landmarks.map((l)=>[\n                l.ref.current,\n                l\n            ]));\n        let currentElement = element;\n        while(currentElement && !landmarkMap.has(currentElement) && currentElement !== document.body && currentElement.parentElement)currentElement = currentElement.parentElement;\n        return landmarkMap.get(currentElement);\n    }\n    /**\n   * Gets the next landmark, in DOM focus order, or previous if backwards is specified.\n   * If last landmark, next should be the first landmark.\n   * If not inside a landmark, will return first landmark.\n   * Returns undefined if there are no landmarks.\n   */ getNextLandmark(element, { backward: backward }) {\n        var _this_landmarks_nextLandmarkIndex_ref_current;\n        let currentLandmark = this.closestLandmark(element);\n        let nextLandmarkIndex = backward ? this.landmarks.length - 1 : 0;\n        if (currentLandmark) nextLandmarkIndex = this.landmarks.indexOf(currentLandmark) + (backward ? -1 : 1);\n        let wrapIfNeeded = ()=>{\n            // When we reach the end of the landmark sequence, fire a custom event that can be listened for by applications.\n            // If this event is canceled, we return immediately. This can be used to implement landmark navigation across iframes.\n            if (nextLandmarkIndex < 0) {\n                if (!element.dispatchEvent(new CustomEvent('react-aria-landmark-navigation', {\n                    detail: {\n                        direction: 'backward'\n                    },\n                    bubbles: true,\n                    cancelable: true\n                }))) return true;\n                nextLandmarkIndex = this.landmarks.length - 1;\n            } else if (nextLandmarkIndex >= this.landmarks.length) {\n                if (!element.dispatchEvent(new CustomEvent('react-aria-landmark-navigation', {\n                    detail: {\n                        direction: 'forward'\n                    },\n                    bubbles: true,\n                    cancelable: true\n                }))) return true;\n                nextLandmarkIndex = 0;\n            }\n            if (nextLandmarkIndex < 0 || nextLandmarkIndex >= this.landmarks.length) return true;\n            return false;\n        };\n        if (wrapIfNeeded()) return undefined;\n        // Skip over hidden landmarks.\n        let i = nextLandmarkIndex;\n        while((_this_landmarks_nextLandmarkIndex_ref_current = this.landmarks[nextLandmarkIndex].ref.current) === null || _this_landmarks_nextLandmarkIndex_ref_current === void 0 ? void 0 : _this_landmarks_nextLandmarkIndex_ref_current.closest('[aria-hidden=true]')){\n            nextLandmarkIndex += backward ? -1 : 1;\n            if (wrapIfNeeded()) return undefined;\n            if (nextLandmarkIndex === i) break;\n        }\n        return this.landmarks[nextLandmarkIndex];\n    }\n    /**\n   * Look at next landmark. If an element was previously focused inside, restore focus there.\n   * If not, focus the landmark itself.\n   * If no landmarks at all, or none with focusable elements, don't move focus.\n   */ f6Handler(e) {\n        if (e.key === 'F6') {\n            // If alt key pressed, focus main landmark, otherwise navigate forward or backward based on shift key.\n            let handled = e.altKey ? this.focusMain() : this.navigate(e.target, e.shiftKey);\n            if (handled) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n    }\n    focusMain() {\n        let main = this.getLandmarkByRole('main');\n        if (main && main.ref.current && document.contains(main.ref.current)) {\n            this.focusLandmark(main.ref.current, 'forward');\n            return true;\n        }\n        return false;\n    }\n    navigate(from, backward) {\n        let nextLandmark = this.getNextLandmark(from, {\n            backward: backward\n        });\n        if (!nextLandmark) return false;\n        // If something was previously focused in the next landmark, then return focus to it\n        if (nextLandmark.lastFocused) {\n            let lastFocused = nextLandmark.lastFocused;\n            if (document.body.contains(lastFocused)) {\n                lastFocused.focus();\n                return true;\n            }\n        }\n        // Otherwise, focus the landmark itself\n        if (nextLandmark.ref.current && document.contains(nextLandmark.ref.current)) {\n            this.focusLandmark(nextLandmark.ref.current, backward ? 'backward' : 'forward');\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Sets lastFocused for a landmark, if focus is moved within that landmark.\n   * Lets the last focused landmark know it was blurred if something else is focused.\n   */ focusinHandler(e) {\n        let currentLandmark = this.closestLandmark(e.target);\n        if (currentLandmark && currentLandmark.ref.current !== e.target) this.updateLandmark({\n            ref: currentLandmark.ref,\n            lastFocused: e.target\n        });\n        let previousFocusedElement = e.relatedTarget;\n        if (previousFocusedElement) {\n            let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n            if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();\n        }\n    }\n    /**\n   * Track if the focus is lost to the body. If it is, do cleanup on the landmark that last had focus.\n   */ focusoutHandler(e) {\n        let previousFocusedElement = e.target;\n        let nextFocusedElement = e.relatedTarget;\n        // the === document seems to be a jest thing for focus to go there on generic blur event such as landmark.blur();\n        // browsers appear to send focus instead to document.body and the relatedTarget is null when that happens\n        if (!nextFocusedElement || nextFocusedElement === document) {\n            let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n            if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();\n        }\n    }\n    createLandmarkController() {\n        let instance = this;\n        instance.refCount++;\n        instance.setupIfNeeded();\n        return {\n            navigate (direction, opts) {\n                let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n                return instance.navigate(element, direction === 'backward');\n            },\n            focusNext (opts) {\n                let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n                return instance.navigate(element, false);\n            },\n            focusPrevious (opts) {\n                let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n                return instance.navigate(element, true);\n            },\n            focusMain () {\n                return instance.focusMain();\n            },\n            dispose () {\n                if (instance) {\n                    instance.refCount--;\n                    instance.teardownIfNeeded();\n                    instance = null;\n                }\n            }\n        };\n    }\n    registerLandmark(landmark) {\n        if (this.landmarks.find((l)=>l.ref === landmark.ref)) this.updateLandmark(landmark);\n        else this.addLandmark(landmark);\n        return ()=>this.removeLandmark(landmark.ref);\n    }\n    constructor(){\n        this.landmarks = [];\n        this.isListening = false;\n        this.refCount = 0;\n        this.version = $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION;\n        this.f6Handler = this.f6Handler.bind(this);\n        this.focusinHandler = this.focusinHandler.bind(this);\n        this.focusoutHandler = this.focusoutHandler.bind(this);\n    }\n}\nfunction $a86207c5d7f7e1fb$export$a8e2debc6521490c() {\n    // Get the current landmark manager and create a controller using it.\n    let instance = $a86207c5d7f7e1fb$var$getLandmarkManager();\n    let controller = instance === null || instance === void 0 ? void 0 : instance.createLandmarkController();\n    let unsubscribe = $a86207c5d7f7e1fb$var$subscribe(()=>{\n        // If the landmark manager changes, dispose the old\n        // controller and create a new one.\n        controller === null || controller === void 0 ? void 0 : controller.dispose();\n        instance = $a86207c5d7f7e1fb$var$getLandmarkManager();\n        controller = instance === null || instance === void 0 ? void 0 : instance.createLandmarkController();\n    });\n    // Return a wrapper that proxies requests to the current controller instance.\n    return {\n        navigate (direction, opts) {\n            return controller.navigate(direction, opts);\n        },\n        focusNext (opts) {\n            return controller.focusNext(opts);\n        },\n        focusPrevious (opts) {\n            return controller.focusPrevious(opts);\n        },\n        focusMain () {\n            return controller.focusMain();\n        },\n        dispose () {\n            controller === null || controller === void 0 ? void 0 : controller.dispose();\n            unsubscribe();\n            controller = undefined;\n            instance = null;\n        }\n    };\n}\nfunction $a86207c5d7f7e1fb$export$4cc632584fd87fae(props, ref) {\n    const { role: role, 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledby, focus: focus } = props;\n    let manager = $a86207c5d7f7e1fb$var$useLandmarkManager();\n    let label = ariaLabel || ariaLabelledby;\n    let [isLandmarkFocused, setIsLandmarkFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let defaultFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setIsLandmarkFocused(true);\n    }, [\n        setIsLandmarkFocused\n    ]);\n    let blur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setIsLandmarkFocused(false);\n    }, [\n        setIsLandmarkFocused\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        if (manager) return manager.registerLandmark({\n            ref: ref,\n            label: label,\n            role: role,\n            focus: focus || defaultFocus,\n            blur: blur\n        });\n    }, [\n        manager,\n        label,\n        ref,\n        role,\n        focus,\n        defaultFocus,\n        blur\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _ref_current;\n        if (isLandmarkFocused) (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();\n    }, [\n        isLandmarkFocused,\n        ref\n    ]);\n    return {\n        landmarkProps: {\n            role: role,\n            tabIndex: isLandmarkFocused ? -1 : undefined,\n            'aria-label': ariaLabel,\n            'aria-labelledby': ariaLabelledby\n        }\n    };\n}\n\n\n\n//# sourceMappingURL=useLandmark.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LWFyaWErbGFuZG1hcmtAMy4wLjRfX2JjOTdkY2I3YzBiZGE4ZTg5YTRiMTk5MjM5YTVlMTM5L25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS9sYW5kbWFyay9kaXN0L3VzZUxhbmRtYXJrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvSDtBQUN4QztBQUM4Qjs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVGQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBb0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBb0Isa0ZBQWtGLEtBQUs7QUFDaEsscUJBQXFCLElBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsS0FBSyxjQUFjLE1BQU07QUFDNUc7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUZBQXVGO0FBQ25HO0FBQ0E7QUFDQSx3REFBd0QsMkNBQWU7QUFDdkUsMkJBQTJCLDhDQUFrQjtBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFrQjtBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSw4REFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBZ0I7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdrSjtBQUNsSiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pblxcRGVza3RvcFxcbmV3XFxjbG91ZGZsYXJlLXdvcmtlcnMtbmV4dGpzLXNhYXMtdGVtcGxhdGVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEByZWFjdC1hcmlhK2xhbmRtYXJrQDMuMC40X19iYzk3ZGNiN2MwYmRhOGU4OWE0YjE5OTIzOWE1ZTEzOVxcbm9kZV9tb2R1bGVzXFxAcmVhY3QtYXJpYVxcbGFuZG1hcmtcXGRpc3RcXHVzZUxhbmRtYXJrLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVN0YXRlIGFzICQzeEN3aCR1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgYXMgJDN4Q3doJHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgYXMgJDN4Q3doJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUxheW91dEVmZmVjdCBhcyAkM3hDd2gkdXNlTGF5b3V0RWZmZWN0fSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcbmltcG9ydCB7dXNlU3luY0V4dGVybmFsU3RvcmUgYXMgJDN4Q3doJHVzZVN5bmNFeHRlcm5hbFN0b3JlfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuLy8gSW5jcmVtZW50IHRoaXMgdmVyc2lvbiBudW1iZXIgd2hlbmV2ZXIgdGhlXG4vLyBMYW5kbWFya01hbmFnZXJBcGkgb3IgTGFuZG1hcmsgaW50ZXJmYWNlcyBjaGFuZ2UuXG5jb25zdCAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkTEFORE1BUktfQVBJX1ZFUlNJT04gPSAxO1xuLy8gU3ltYm9sIHVuZGVyIHdoaWNoIHRoZSBzaW5nbGV0b24gbGFuZG1hcmsgbWFuYWdlciBpbnN0YW5jZSBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQuXG5jb25zdCAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkbGFuZG1hcmtTeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC1hcmlhLWxhbmRtYXJrLW1hbmFnZXInKTtcbmZ1bmN0aW9uICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRzdWJzY3JpYmUoZm4pIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFjdC1hcmlhLWxhbmRtYXJrLW1hbmFnZXItY2hhbmdlJywgZm4pO1xuICAgIHJldHVybiAoKT0+ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVhY3QtYXJpYS1sYW5kbWFyay1tYW5hZ2VyLWNoYW5nZScsIGZuKTtcbn1cbmZ1bmN0aW9uICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRnZXRMYW5kbWFya01hbmFnZXIoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xuICAgIC8vIFJldXNlIGFuIGV4aXN0aW5nIGluc3RhbmNlIGlmIGl0IGhhcyB0aGUgc2FtZSBvciBncmVhdGVyIHZlcnNpb24uXG4gICAgbGV0IGluc3RhbmNlID0gZG9jdW1lbnRbJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGxhbmRtYXJrU3ltYm9sXTtcbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UudmVyc2lvbiA+PSAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkTEFORE1BUktfQVBJX1ZFUlNJT04pIHJldHVybiBpbnN0YW5jZTtcbiAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBhbmQgZGlzcGF0Y2ggYW4gZXZlbnQgc28gYW55dGhpbmcgdXNpbmcgdGhlIGV4aXN0aW5nXG4gICAgLy8gaW5zdGFuY2UgdXBkYXRlcyBhbmQgcmUtcmVnaXN0ZXJzIHRoZWlyIGxhbmRtYXJrcyB3aXRoIHRoZSBuZXcgb25lLlxuICAgIGRvY3VtZW50WyRhODYyMDdjNWQ3ZjdlMWZiJHZhciRsYW5kbWFya1N5bWJvbF0gPSBuZXcgJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJExhbmRtYXJrTWFuYWdlcigpO1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdyZWFjdC1hcmlhLWxhbmRtYXJrLW1hbmFnZXItY2hhbmdlJykpO1xuICAgIHJldHVybiBkb2N1bWVudFskYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkbGFuZG1hcmtTeW1ib2xdO1xufVxuLy8gU3Vic2NyaWJlcyBhIFJlYWN0IGNvbXBvbmVudCB0byB0aGUgY3VycmVudCBsYW5kbWFyayBtYW5hZ2VyIGluc3RhbmNlLlxuZnVuY3Rpb24gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJHVzZUxhbmRtYXJrTWFuYWdlcigpIHtcbiAgICByZXR1cm4gKDAsICQzeEN3aCR1c2VTeW5jRXh0ZXJuYWxTdG9yZSkoJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJHN1YnNjcmliZSwgJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGdldExhbmRtYXJrTWFuYWdlciwgJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGdldExhbmRtYXJrTWFuYWdlcik7XG59XG5jbGFzcyAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkTGFuZG1hcmtNYW5hZ2VyIHtcbiAgICBzZXR1cElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xpc3RlbmluZykgcmV0dXJuO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5mNkhhbmRsZXIsIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLmZvY3VzaW5IYW5kbGVyLCB7XG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuZm9jdXNvdXRIYW5kbGVyLCB7XG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdGVhcmRvd25JZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTGlzdGVuaW5nIHx8IHRoaXMubGFuZG1hcmtzLmxlbmd0aCA+IDAgfHwgdGhpcy5yZWZDb3VudCA+IDApIHJldHVybjtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuZjZIYW5kbGVyLCB7XG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5mb2N1c2luSGFuZGxlciwge1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLmZvY3Vzb3V0SGFuZGxlciwge1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBmb2N1c0xhbmRtYXJrKGxhbmRtYXJrLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzX2xhbmRtYXJrc19maW5kX2ZvY3VzLCBfdGhpc19sYW5kbWFya3NfZmluZDtcbiAgICAgICAgKF90aGlzX2xhbmRtYXJrc19maW5kID0gdGhpcy5sYW5kbWFya3MuZmluZCgobCk9PmwucmVmLmN1cnJlbnQgPT09IGxhbmRtYXJrKSkgPT09IG51bGwgfHwgX3RoaXNfbGFuZG1hcmtzX2ZpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpc19sYW5kbWFya3NfZmluZF9mb2N1cyA9IF90aGlzX2xhbmRtYXJrc19maW5kLmZvY3VzKSA9PT0gbnVsbCB8fCBfdGhpc19sYW5kbWFya3NfZmluZF9mb2N1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfbGFuZG1hcmtzX2ZpbmRfZm9jdXMuY2FsbChfdGhpc19sYW5kbWFya3NfZmluZCwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybiBzZXQgb2YgbGFuZG1hcmtzIHdpdGggYSBzcGVjaWZpYyByb2xlLlxuICAgKi8gZ2V0TGFuZG1hcmtzQnlSb2xlKHJvbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5sYW5kbWFya3MuZmlsdGVyKChsKT0+bC5yb2xlID09PSByb2xlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgbGFuZG1hcmsgd2l0aCBhIHNwZWNpZmljIHJvbGUuXG4gICAqLyBnZXRMYW5kbWFya0J5Um9sZShyb2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhbmRtYXJrcy5maW5kKChsKT0+bC5yb2xlID09PSByb2xlKTtcbiAgICB9XG4gICAgYWRkTGFuZG1hcmsobmV3TGFuZG1hcmspIHtcbiAgICAgICAgdGhpcy5zZXR1cElmTmVlZGVkKCk7XG4gICAgICAgIGlmICh0aGlzLmxhbmRtYXJrcy5maW5kKChsYW5kbWFyayk9PmxhbmRtYXJrLnJlZiA9PT0gbmV3TGFuZG1hcmsucmVmKSB8fCAhbmV3TGFuZG1hcmsucmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMubGFuZG1hcmtzLmZpbHRlcigobGFuZG1hcmspPT5sYW5kbWFyay5yb2xlID09PSAnbWFpbicpLmxlbmd0aCA+IDEgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgY29uc29sZS5lcnJvcignUGFnZSBjYW4gY29udGFpbiBubyBtb3JlIHRoYW4gb25lIGxhbmRtYXJrIHdpdGggdGhlIHJvbGUgXCJtYWluXCIuJyk7XG4gICAgICAgIGlmICh0aGlzLmxhbmRtYXJrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubGFuZG1hcmtzID0gW1xuICAgICAgICAgICAgICAgIG5ld0xhbmRtYXJrXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5jaGVja0xhYmVscyhuZXdMYW5kbWFyay5yb2xlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCaW5hcnkgc2VhcmNoIHRvIGluc2VydCBuZXcgbGFuZG1hcmsgYmFzZWQgb24gcG9zaXRpb24gaW4gZG9jdW1lbnQgcmVsYXRpdmUgdG8gZXhpc3RpbmcgbGFuZG1hcmtzLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5sYW5kbWFya3MubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUoc3RhcnQgPD0gZW5kKXtcbiAgICAgICAgICAgIGxldCBtaWQgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICAgICAgICAgIGxldCBjb21wYXJlZFBvc2l0aW9uID0gbmV3TGFuZG1hcmsucmVmLmN1cnJlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5sYW5kbWFya3NbbWlkXS5yZWYuY3VycmVudCk7XG4gICAgICAgICAgICBsZXQgaXNOZXdBZnRlckV4aXN0aW5nID0gQm9vbGVhbihjb21wYXJlZFBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgfHwgY29tcGFyZWRQb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMpO1xuICAgICAgICAgICAgaWYgKGlzTmV3QWZ0ZXJFeGlzdGluZykgc3RhcnQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSBlbmQgPSBtaWQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFuZG1hcmtzLnNwbGljZShzdGFydCwgMCwgbmV3TGFuZG1hcmspO1xuICAgICAgICB0aGlzLmNoZWNrTGFiZWxzKG5ld0xhbmRtYXJrLnJvbGUpO1xuICAgIH1cbiAgICB1cGRhdGVMYW5kbWFyayhsYW5kbWFyaykge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmxhbmRtYXJrcy5maW5kSW5kZXgoKGwpPT5sLnJlZiA9PT0gbGFuZG1hcmsucmVmKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMubGFuZG1hcmtzW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmxhbmRtYXJrc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgLi4ubGFuZG1hcmtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNoZWNrTGFiZWxzKHRoaXMubGFuZG1hcmtzW2luZGV4XS5yb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVMYW5kbWFyayhyZWYpIHtcbiAgICAgICAgdGhpcy5sYW5kbWFya3MgPSB0aGlzLmxhbmRtYXJrcy5maWx0ZXIoKGxhbmRtYXJrKT0+bGFuZG1hcmsucmVmICE9PSByZWYpO1xuICAgICAgICB0aGlzLnRlYXJkb3duSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUgYXJlIDIrIGxhbmRtYXJrcyB3aXRoIHRoZSBzYW1lIHJvbGUgYnV0IG5vIGxhYmVsLlxuICAgKiBMYWJlbHMgZm9yIGxhbmRtYXJrcyB3aXRoIHRoZSBzYW1lIHJvbGUgbXVzdCBhbHNvIGJlIHVuaXF1ZS5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcHJhY3RpY2VzL2xhbmRtYXJrLXJlZ2lvbnMvLlxuICAgKi8gY2hlY2tMYWJlbHMocm9sZSkge1xuICAgICAgICBsZXQgbGFuZG1hcmtzV2l0aFJvbGUgPSB0aGlzLmdldExhbmRtYXJrc0J5Um9sZShyb2xlKTtcbiAgICAgICAgaWYgKGxhbmRtYXJrc1dpdGhSb2xlLnNpemUgPiAxKSB7XG4gICAgICAgICAgICBsZXQgZHVwbGljYXRlc1dpdGhvdXRMYWJlbCA9IFtcbiAgICAgICAgICAgICAgICAuLi5sYW5kbWFya3NXaXRoUm9sZVxuICAgICAgICAgICAgXS5maWx0ZXIoKGxhbmRtYXJrKT0+IWxhbmRtYXJrLmxhYmVsKTtcbiAgICAgICAgICAgIGlmIChkdXBsaWNhdGVzV2l0aG91dExhYmVsLmxlbmd0aCA+IDAgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgY29uc29sZS53YXJuKGBQYWdlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgbGFuZG1hcmsgd2l0aCB0aGUgJyR7cm9sZX0nIHJvbGUuIElmIHR3byBvciBtb3JlIGxhbmRtYXJrcyBvbiBhIHBhZ2Ugc2hhcmUgdGhlIHNhbWUgcm9sZSwgYWxsIG11c3QgYmUgbGFiZWxlZCB3aXRoIGFuIGFyaWEtbGFiZWwgb3IgYXJpYS1sYWJlbGxlZGJ5IGF0dHJpYnV0ZTogYCwgZHVwbGljYXRlc1dpdGhvdXRMYWJlbC5tYXAoKGxhbmRtYXJrKT0+bGFuZG1hcmsucmVmLmN1cnJlbnQpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWxzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5sYW5kbWFya3NXaXRoUm9sZVxuICAgICAgICAgICAgICAgIF0ubWFwKChsYW5kbWFyayk9PmxhbmRtYXJrLmxhYmVsKTtcbiAgICAgICAgICAgICAgICBsZXQgZHVwbGljYXRlTGFiZWxzID0gbGFiZWxzLmZpbHRlcigoaXRlbSwgaW5kZXgpPT5sYWJlbHMuaW5kZXhPZihpdGVtKSAhPT0gaW5kZXgpO1xuICAgICAgICAgICAgICAgIGR1cGxpY2F0ZUxhYmVscy5mb3JFYWNoKChsYWJlbCk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBQYWdlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgbGFuZG1hcmsgd2l0aCB0aGUgJyR7cm9sZX0nIHJvbGUgYW5kICcke2xhYmVsfScgbGFiZWwuIElmIHR3byBvciBtb3JlIGxhbmRtYXJrcyBvbiBhIHBhZ2Ugc2hhcmUgdGhlIHNhbWUgcm9sZSwgdGhleSBtdXN0IGhhdmUgdW5pcXVlIGxhYmVsczogYCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubGFuZG1hcmtzV2l0aFJvbGVcbiAgICAgICAgICAgICAgICAgICAgXS5maWx0ZXIoKGxhbmRtYXJrKT0+bGFuZG1hcmsubGFiZWwgPT09IGxhYmVsKS5tYXAoKGxhbmRtYXJrKT0+bGFuZG1hcmsucmVmLmN1cnJlbnQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICogR2V0IHRoZSBsYW5kbWFyayB0aGF0IGlzIHRoZSBjbG9zZXN0IHBhcmVudCBpbiB0aGUgRE9NLlxuICAgKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBwYXJlbnQgaXMgYSBsYW5kbWFyay5cbiAgICovIGNsb3Nlc3RMYW5kbWFyayhlbGVtZW50KSB7XG4gICAgICAgIGxldCBsYW5kbWFya01hcCA9IG5ldyBNYXAodGhpcy5sYW5kbWFya3MubWFwKChsKT0+W1xuICAgICAgICAgICAgICAgIGwucmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB3aGlsZShjdXJyZW50RWxlbWVudCAmJiAhbGFuZG1hcmtNYXAuaGFzKGN1cnJlbnRFbGVtZW50KSAmJiBjdXJyZW50RWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KWN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhbmRtYXJrTWFwLmdldChjdXJyZW50RWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSBuZXh0IGxhbmRtYXJrLCBpbiBET00gZm9jdXMgb3JkZXIsIG9yIHByZXZpb3VzIGlmIGJhY2t3YXJkcyBpcyBzcGVjaWZpZWQuXG4gICAqIElmIGxhc3QgbGFuZG1hcmssIG5leHQgc2hvdWxkIGJlIHRoZSBmaXJzdCBsYW5kbWFyay5cbiAgICogSWYgbm90IGluc2lkZSBhIGxhbmRtYXJrLCB3aWxsIHJldHVybiBmaXJzdCBsYW5kbWFyay5cbiAgICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIGxhbmRtYXJrcy5cbiAgICovIGdldE5leHRMYW5kbWFyayhlbGVtZW50LCB7IGJhY2t3YXJkOiBiYWNrd2FyZCB9KSB7XG4gICAgICAgIHZhciBfdGhpc19sYW5kbWFya3NfbmV4dExhbmRtYXJrSW5kZXhfcmVmX2N1cnJlbnQ7XG4gICAgICAgIGxldCBjdXJyZW50TGFuZG1hcmsgPSB0aGlzLmNsb3Nlc3RMYW5kbWFyayhlbGVtZW50KTtcbiAgICAgICAgbGV0IG5leHRMYW5kbWFya0luZGV4ID0gYmFja3dhcmQgPyB0aGlzLmxhbmRtYXJrcy5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgaWYgKGN1cnJlbnRMYW5kbWFyaykgbmV4dExhbmRtYXJrSW5kZXggPSB0aGlzLmxhbmRtYXJrcy5pbmRleE9mKGN1cnJlbnRMYW5kbWFyaykgKyAoYmFja3dhcmQgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgd3JhcElmTmVlZGVkID0gKCk9PntcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgbGFuZG1hcmsgc2VxdWVuY2UsIGZpcmUgYSBjdXN0b20gZXZlbnQgdGhhdCBjYW4gYmUgbGlzdGVuZWQgZm9yIGJ5IGFwcGxpY2F0aW9ucy5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgZXZlbnQgaXMgY2FuY2VsZWQsIHdlIHJldHVybiBpbW1lZGlhdGVseS4gVGhpcyBjYW4gYmUgdXNlZCB0byBpbXBsZW1lbnQgbGFuZG1hcmsgbmF2aWdhdGlvbiBhY3Jvc3MgaWZyYW1lcy5cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZG1hcmtJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3JlYWN0LWFyaWEtbGFuZG1hcmstbmF2aWdhdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbmV4dExhbmRtYXJrSW5kZXggPSB0aGlzLmxhbmRtYXJrcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0TGFuZG1hcmtJbmRleCA+PSB0aGlzLmxhbmRtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3JlYWN0LWFyaWEtbGFuZG1hcmstbmF2aWdhdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBuZXh0TGFuZG1hcmtJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dExhbmRtYXJrSW5kZXggPCAwIHx8IG5leHRMYW5kbWFya0luZGV4ID49IHRoaXMubGFuZG1hcmtzLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh3cmFwSWZOZWVkZWQoKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gU2tpcCBvdmVyIGhpZGRlbiBsYW5kbWFya3MuXG4gICAgICAgIGxldCBpID0gbmV4dExhbmRtYXJrSW5kZXg7XG4gICAgICAgIHdoaWxlKChfdGhpc19sYW5kbWFya3NfbmV4dExhbmRtYXJrSW5kZXhfcmVmX2N1cnJlbnQgPSB0aGlzLmxhbmRtYXJrc1tuZXh0TGFuZG1hcmtJbmRleF0ucmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF90aGlzX2xhbmRtYXJrc19uZXh0TGFuZG1hcmtJbmRleF9yZWZfY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfbGFuZG1hcmtzX25leHRMYW5kbWFya0luZGV4X3JlZl9jdXJyZW50LmNsb3Nlc3QoJ1thcmlhLWhpZGRlbj10cnVlXScpKXtcbiAgICAgICAgICAgIG5leHRMYW5kbWFya0luZGV4ICs9IGJhY2t3YXJkID8gLTEgOiAxO1xuICAgICAgICAgICAgaWYgKHdyYXBJZk5lZWRlZCgpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG5leHRMYW5kbWFya0luZGV4ID09PSBpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYW5kbWFya3NbbmV4dExhbmRtYXJrSW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICogTG9vayBhdCBuZXh0IGxhbmRtYXJrLiBJZiBhbiBlbGVtZW50IHdhcyBwcmV2aW91c2x5IGZvY3VzZWQgaW5zaWRlLCByZXN0b3JlIGZvY3VzIHRoZXJlLlxuICAgKiBJZiBub3QsIGZvY3VzIHRoZSBsYW5kbWFyayBpdHNlbGYuXG4gICAqIElmIG5vIGxhbmRtYXJrcyBhdCBhbGwsIG9yIG5vbmUgd2l0aCBmb2N1c2FibGUgZWxlbWVudHMsIGRvbid0IG1vdmUgZm9jdXMuXG4gICAqLyBmNkhhbmRsZXIoZSkge1xuICAgICAgICBpZiAoZS5rZXkgPT09ICdGNicpIHtcbiAgICAgICAgICAgIC8vIElmIGFsdCBrZXkgcHJlc3NlZCwgZm9jdXMgbWFpbiBsYW5kbWFyaywgb3RoZXJ3aXNlIG5hdmlnYXRlIGZvcndhcmQgb3IgYmFja3dhcmQgYmFzZWQgb24gc2hpZnQga2V5LlxuICAgICAgICAgICAgbGV0IGhhbmRsZWQgPSBlLmFsdEtleSA/IHRoaXMuZm9jdXNNYWluKCkgOiB0aGlzLm5hdmlnYXRlKGUudGFyZ2V0LCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9jdXNNYWluKCkge1xuICAgICAgICBsZXQgbWFpbiA9IHRoaXMuZ2V0TGFuZG1hcmtCeVJvbGUoJ21haW4nKTtcbiAgICAgICAgaWYgKG1haW4gJiYgbWFpbi5yZWYuY3VycmVudCAmJiBkb2N1bWVudC5jb250YWlucyhtYWluLnJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0xhbmRtYXJrKG1haW4ucmVmLmN1cnJlbnQsICdmb3J3YXJkJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG5hdmlnYXRlKGZyb20sIGJhY2t3YXJkKSB7XG4gICAgICAgIGxldCBuZXh0TGFuZG1hcmsgPSB0aGlzLmdldE5leHRMYW5kbWFyayhmcm9tLCB7XG4gICAgICAgICAgICBiYWNrd2FyZDogYmFja3dhcmRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghbmV4dExhbmRtYXJrKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgcHJldmlvdXNseSBmb2N1c2VkIGluIHRoZSBuZXh0IGxhbmRtYXJrLCB0aGVuIHJldHVybiBmb2N1cyB0byBpdFxuICAgICAgICBpZiAobmV4dExhbmRtYXJrLmxhc3RGb2N1c2VkKSB7XG4gICAgICAgICAgICBsZXQgbGFzdEZvY3VzZWQgPSBuZXh0TGFuZG1hcmsubGFzdEZvY3VzZWQ7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyhsYXN0Rm9jdXNlZCkpIHtcbiAgICAgICAgICAgICAgICBsYXN0Rm9jdXNlZC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgZm9jdXMgdGhlIGxhbmRtYXJrIGl0c2VsZlxuICAgICAgICBpZiAobmV4dExhbmRtYXJrLnJlZi5jdXJyZW50ICYmIGRvY3VtZW50LmNvbnRhaW5zKG5leHRMYW5kbWFyay5yZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNMYW5kbWFyayhuZXh0TGFuZG1hcmsucmVmLmN1cnJlbnQsIGJhY2t3YXJkID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIGxhc3RGb2N1c2VkIGZvciBhIGxhbmRtYXJrLCBpZiBmb2N1cyBpcyBtb3ZlZCB3aXRoaW4gdGhhdCBsYW5kbWFyay5cbiAgICogTGV0cyB0aGUgbGFzdCBmb2N1c2VkIGxhbmRtYXJrIGtub3cgaXQgd2FzIGJsdXJyZWQgaWYgc29tZXRoaW5nIGVsc2UgaXMgZm9jdXNlZC5cbiAgICovIGZvY3VzaW5IYW5kbGVyKGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRMYW5kbWFyayA9IHRoaXMuY2xvc2VzdExhbmRtYXJrKGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKGN1cnJlbnRMYW5kbWFyayAmJiBjdXJyZW50TGFuZG1hcmsucmVmLmN1cnJlbnQgIT09IGUudGFyZ2V0KSB0aGlzLnVwZGF0ZUxhbmRtYXJrKHtcbiAgICAgICAgICAgIHJlZjogY3VycmVudExhbmRtYXJrLnJlZixcbiAgICAgICAgICAgIGxhc3RGb2N1c2VkOiBlLnRhcmdldFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHByZXZpb3VzRm9jdXNlZEVsZW1lbnQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIGlmIChwcmV2aW91c0ZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsgPSB0aGlzLmNsb3Nlc3RMYW5kbWFyayhwcmV2aW91c0ZvY3VzZWRFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UHJldmlvdXNMYW5kbWFyayAmJiBjbG9zZXN0UHJldmlvdXNMYW5kbWFyay5yZWYuY3VycmVudCA9PT0gcHJldmlvdXNGb2N1c2VkRWxlbWVudCkgY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBUcmFjayBpZiB0aGUgZm9jdXMgaXMgbG9zdCB0byB0aGUgYm9keS4gSWYgaXQgaXMsIGRvIGNsZWFudXAgb24gdGhlIGxhbmRtYXJrIHRoYXQgbGFzdCBoYWQgZm9jdXMuXG4gICAqLyBmb2N1c291dEhhbmRsZXIoZSkge1xuICAgICAgICBsZXQgcHJldmlvdXNGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0O1xuICAgICAgICBsZXQgbmV4dEZvY3VzZWRFbGVtZW50ID0gZS5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAvLyB0aGUgPT09IGRvY3VtZW50IHNlZW1zIHRvIGJlIGEgamVzdCB0aGluZyBmb3IgZm9jdXMgdG8gZ28gdGhlcmUgb24gZ2VuZXJpYyBibHVyIGV2ZW50IHN1Y2ggYXMgbGFuZG1hcmsuYmx1cigpO1xuICAgICAgICAvLyBicm93c2VycyBhcHBlYXIgdG8gc2VuZCBmb2N1cyBpbnN0ZWFkIHRvIGRvY3VtZW50LmJvZHkgYW5kIHRoZSByZWxhdGVkVGFyZ2V0IGlzIG51bGwgd2hlbiB0aGF0IGhhcHBlbnNcbiAgICAgICAgaWYgKCFuZXh0Rm9jdXNlZEVsZW1lbnQgfHwgbmV4dEZvY3VzZWRFbGVtZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgbGV0IGNsb3Nlc3RQcmV2aW91c0xhbmRtYXJrID0gdGhpcy5jbG9zZXN0TGFuZG1hcmsocHJldmlvdXNGb2N1c2VkRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsgJiYgY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsucmVmLmN1cnJlbnQgPT09IHByZXZpb3VzRm9jdXNlZEVsZW1lbnQpIGNsb3Nlc3RQcmV2aW91c0xhbmRtYXJrLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVMYW5kbWFya0NvbnRyb2xsZXIoKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIGluc3RhbmNlLnJlZkNvdW50Kys7XG4gICAgICAgIGluc3RhbmNlLnNldHVwSWZOZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hdmlnYXRlIChkaXJlY3Rpb24sIG9wdHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZnJvbSkgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UubmF2aWdhdGUoZWxlbWVudCwgZGlyZWN0aW9uID09PSAnYmFja3dhcmQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1c05leHQgKG9wdHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZnJvbSkgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UubmF2aWdhdGUoZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzUHJldmlvdXMgKG9wdHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZnJvbSkgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UubmF2aWdhdGUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXNNYWluICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuZm9jdXNNYWluKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcG9zZSAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlZkNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnRlYXJkb3duSWZOZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJMYW5kbWFyayhsYW5kbWFyaykge1xuICAgICAgICBpZiAodGhpcy5sYW5kbWFya3MuZmluZCgobCk9PmwucmVmID09PSBsYW5kbWFyay5yZWYpKSB0aGlzLnVwZGF0ZUxhbmRtYXJrKGxhbmRtYXJrKTtcbiAgICAgICAgZWxzZSB0aGlzLmFkZExhbmRtYXJrKGxhbmRtYXJrKTtcbiAgICAgICAgcmV0dXJuICgpPT50aGlzLnJlbW92ZUxhbmRtYXJrKGxhbmRtYXJrLnJlZik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMubGFuZG1hcmtzID0gW107XG4gICAgICAgIHRoaXMuaXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9ICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRMQU5ETUFSS19BUElfVkVSU0lPTjtcbiAgICAgICAgdGhpcy5mNkhhbmRsZXIgPSB0aGlzLmY2SGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZvY3VzaW5IYW5kbGVyID0gdGhpcy5mb2N1c2luSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZvY3Vzb3V0SGFuZGxlciA9IHRoaXMuZm9jdXNvdXRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gJGE4NjIwN2M1ZDdmN2UxZmIkZXhwb3J0JGE4ZTJkZWJjNjUyMTQ5MGMoKSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGxhbmRtYXJrIG1hbmFnZXIgYW5kIGNyZWF0ZSBhIGNvbnRyb2xsZXIgdXNpbmcgaXQuXG4gICAgbGV0IGluc3RhbmNlID0gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGdldExhbmRtYXJrTWFuYWdlcigpO1xuICAgIGxldCBjb250cm9sbGVyID0gaW5zdGFuY2UgPT09IG51bGwgfHwgaW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbmNlLmNyZWF0ZUxhbmRtYXJrQ29udHJvbGxlcigpO1xuICAgIGxldCB1bnN1YnNjcmliZSA9ICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRzdWJzY3JpYmUoKCk9PntcbiAgICAgICAgLy8gSWYgdGhlIGxhbmRtYXJrIG1hbmFnZXIgY2hhbmdlcywgZGlzcG9zZSB0aGUgb2xkXG4gICAgICAgIC8vIGNvbnRyb2xsZXIgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICAgIGNvbnRyb2xsZXIgPT09IG51bGwgfHwgY29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udHJvbGxlci5kaXNwb3NlKCk7XG4gICAgICAgIGluc3RhbmNlID0gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGdldExhbmRtYXJrTWFuYWdlcigpO1xuICAgICAgICBjb250cm9sbGVyID0gaW5zdGFuY2UgPT09IG51bGwgfHwgaW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbmNlLmNyZWF0ZUxhbmRtYXJrQ29udHJvbGxlcigpO1xuICAgIH0pO1xuICAgIC8vIFJldHVybiBhIHdyYXBwZXIgdGhhdCBwcm94aWVzIHJlcXVlc3RzIHRvIHRoZSBjdXJyZW50IGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmF2aWdhdGUgKGRpcmVjdGlvbiwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIubmF2aWdhdGUoZGlyZWN0aW9uLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNOZXh0IChvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5mb2N1c05leHQob3B0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzUHJldmlvdXMgKG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmZvY3VzUHJldmlvdXMob3B0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzTWFpbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5mb2N1c01haW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcG9zZSAoKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyID09PSBudWxsIHx8IGNvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gJGE4NjIwN2M1ZDdmN2UxZmIkZXhwb3J0JDRjYzYzMjU4NGZkODdmYWUocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IHsgcm9sZTogcm9sZSwgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwsICdhcmlhLWxhYmVsbGVkYnknOiBhcmlhTGFiZWxsZWRieSwgZm9jdXM6IGZvY3VzIH0gPSBwcm9wcztcbiAgICBsZXQgbWFuYWdlciA9ICRhODYyMDdjNWQ3ZjdlMWZiJHZhciR1c2VMYW5kbWFya01hbmFnZXIoKTtcbiAgICBsZXQgbGFiZWwgPSBhcmlhTGFiZWwgfHwgYXJpYUxhYmVsbGVkYnk7XG4gICAgbGV0IFtpc0xhbmRtYXJrRm9jdXNlZCwgc2V0SXNMYW5kbWFya0ZvY3VzZWRdID0gKDAsICQzeEN3aCR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBkZWZhdWx0Rm9jdXMgPSAoMCwgJDN4Q3doJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRJc0xhbmRtYXJrRm9jdXNlZCh0cnVlKTtcbiAgICB9LCBbXG4gICAgICAgIHNldElzTGFuZG1hcmtGb2N1c2VkXG4gICAgXSk7XG4gICAgbGV0IGJsdXIgPSAoMCwgJDN4Q3doJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRJc0xhbmRtYXJrRm9jdXNlZChmYWxzZSk7XG4gICAgfSwgW1xuICAgICAgICBzZXRJc0xhbmRtYXJrRm9jdXNlZFxuICAgIF0pO1xuICAgICgwLCAkM3hDd2gkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAobWFuYWdlcikgcmV0dXJuIG1hbmFnZXIucmVnaXN0ZXJMYW5kbWFyayh7XG4gICAgICAgICAgICByZWY6IHJlZixcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgIHJvbGU6IHJvbGUsXG4gICAgICAgICAgICBmb2N1czogZm9jdXMgfHwgZGVmYXVsdEZvY3VzLFxuICAgICAgICAgICAgYmx1cjogYmx1clxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG1hbmFnZXIsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICByZWYsXG4gICAgICAgIHJvbGUsXG4gICAgICAgIGZvY3VzLFxuICAgICAgICBkZWZhdWx0Rm9jdXMsXG4gICAgICAgIGJsdXJcbiAgICBdKTtcbiAgICAoMCwgJDN4Q3doJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgdmFyIF9yZWZfY3VycmVudDtcbiAgICAgICAgaWYgKGlzTGFuZG1hcmtGb2N1c2VkKSAoX3JlZl9jdXJyZW50ID0gcmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWZfY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlZl9jdXJyZW50LmZvY3VzKCk7XG4gICAgfSwgW1xuICAgICAgICBpc0xhbmRtYXJrRm9jdXNlZCxcbiAgICAgICAgcmVmXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGFuZG1hcmtQcm9wczoge1xuICAgICAgICAgICAgcm9sZTogcm9sZSxcbiAgICAgICAgICAgIHRhYkluZGV4OiBpc0xhbmRtYXJrRm9jdXNlZCA/IC0xIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwsXG4gICAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogYXJpYUxhYmVsbGVkYnlcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuZXhwb3J0IHskYTg2MjA3YzVkN2Y3ZTFmYiRleHBvcnQkYThlMmRlYmM2NTIxNDkwYyBhcyBVTlNUQUJMRV9jcmVhdGVMYW5kbWFya0NvbnRyb2xsZXIsICRhODYyMDdjNWQ3ZjdlMWZiJGV4cG9ydCQ0Y2M2MzI1ODRmZDg3ZmFlIGFzIHVzZUxhbmRtYXJrfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUxhbmRtYXJrLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-aria+landmark@3.0.4__bc97dcb7c0bda8e89a4b199239a5e139/node_modules/@react-aria/landmark/dist/useLandmark.mjs\n");

/***/ })

};
;